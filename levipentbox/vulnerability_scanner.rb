#!/usr/bin/env ruby

# LEVIPENTBOX - Module de Scan de Vuln√©rabilit√©s
# D√©tection avanc√©e des vuln√©rabilit√©s r√©seau

require 'socket'
require 'net/http'
require 'net/https'
require 'uri'
require 'json'
require 'timeout'

class VulnerabilityScanner
  attr_reader :vulnerabilities, :results
  
  def initialize(target, output_dir)
    @target = target
    @output_dir = output_dir
    @vulnerabilities = []
    @results = {}
  end
  
  def log(message, level = 'INFO')
    timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')
    puts "[#{timestamp}] [#{level}] #{message}"
  end
  
  def scan_web_vulnerabilities(port = 80, use_ssl = false)
    log("üîç Scan des vuln√©rabilit√©s web sur #{@target}:#{port}")
    
    protocol = use_ssl ? 'https' : 'http'
    vulns = []
    
    begin
      uri = URI("#{protocol}://#{@target}:#{port}")
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = use_ssl
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.open_timeout = 10
      http.read_timeout = 10
      
      # Test des vuln√©rabilit√©s communes
      vulns.concat(test_security_headers(http, port))
      vulns.concat(test_http_methods(http, port))
      vulns.concat(test_directory_traversal(http, port))
      vulns.concat(test_sql_injection(http, port))
      vulns.concat(test_xss_vulnerabilities(http, port))
      
    rescue => e
      log("Erreur scan web: #{e.message}", 'WARNING')
    end
    
    @vulnerabilities.concat(vulns)
    return vulns
  end
  
  def test_security_headers(http, port)
    vulns = []
    
    begin
      response = http.get('/')
      
      # V√©rifier les en-t√™tes de s√©curit√© manquants
      security_headers = {
        'X-Frame-Options' => 'Clickjacking protection',
        'X-Content-Type-Options' => 'MIME type sniffing protection',
        'X-XSS-Protection' => 'XSS protection',
        'Strict-Transport-Security' => 'HSTS protection',
        'Content-Security-Policy' => 'CSP protection'
      }
      
      security_headers.each do |header, description|
        unless response[header]
          vulns << {
            type: 'Missing Security Header',
            port: port,
            details: "#{header} header missing - #{description}",
            severity: 'Medium'
          }
        end
      end
      
      # V√©rifier la version du serveur
      if response['Server']
        vulns << {
          type: 'Server Information Disclosure',
          port: port,
          details: "Server: #{response['Server']}",
          severity: 'Low'
        }
      end
      
    rescue => e
      log("Erreur test headers: #{e.message}", 'WARNING')
    end
    
    return vulns
  end
  
  def test_http_methods(http, port)
    vulns = []
    
    dangerous_methods = ['TRACE', 'OPTIONS', 'PUT', 'DELETE']
    
    dangerous_methods.each do |method|
      begin
        request = case method
        when 'TRACE'
          Net::HTTP::Trace.new('/')
        when 'OPTIONS'
          Net::HTTP::Options.new('/')
        when 'PUT'
          Net::HTTP::Put.new('/')
        when 'DELETE'
          Net::HTTP::Delete.new('/')
        end
        
        response = http.request(request)
        
        if response.code != '405' && response.code != '501'
          vulns << {
            type: 'Dangerous HTTP Method',
            port: port,
            details: "#{method} method enabled",
            severity: 'High'
          }
        end
      rescue => e
        # M√©thode non support√©e, c'est bien
      end
    end
    
    return vulns
  end
  
  def test_directory_traversal(http, port)
    vulns = []
    
    traversal_paths = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
    ]
    
    traversal_paths.each do |path|
      begin
        response = http.get("/#{path}")
        
        if response.code == '200' && response.body.include?('root:')
          vulns << {
            type: 'Directory Traversal',
            port: port,
            details: "Path traversal possible: #{path}",
            severity: 'Critical'
          }
          break
        end
      rescue => e
        # Erreur attendue
      end
    end
    
    return vulns
  end
  
  def test_sql_injection(http, port)
    vulns = []
    
    sql_payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT NULL--",
      "admin'--",
      "1' AND 1=1--"
    ]
    
    # Test sur des param√®tres communs
    test_params = ['id', 'user', 'search', 'q']
    
    test_params.each do |param|
      sql_payloads.each do |payload|
        begin
          uri = URI("http://#{@target}:#{port}/?#{param}=#{URI.encode_www_form_component(payload)}")
          response = http.get(uri.request_uri)
          
          if response.body.include?('SQL') || response.body.include?('mysql') || response.body.include?('ORA-')
            vulns << {
              type: 'SQL Injection',
              port: port,
              details: "SQL injection possible via #{param} parameter",
              severity: 'Critical'
            }
            break
          end
        rescue => e
          # Erreur attendue
        end
      end
    end
    
    return vulns
  end
  
  def test_xss_vulnerabilities(http, port)
    vulns = []
    
    xss_payloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src=x onerror=alert("XSS")>',
      '"><img src=x onerror=alert("XSS")>'
    ]
    
    test_params = ['q', 'search', 'query', 'input']
    
    test_params.each do |param|
      xss_payloads.each do |payload|
        begin
          uri = URI("http://#{@target}:#{port}/?#{param}=#{URI.encode_www_form_component(payload)}")
          response = http.get(uri.request_uri)
          
          if response.body.include?(payload)
            vulns << {
              type: 'Cross-Site Scripting (XSS)',
              port: port,
              details: "XSS possible via #{param} parameter",
              severity: 'High'
            }
            break
          end
        rescue => e
          # Erreur attendue
        end
      end
    end
    
    return vulns
  end
  
  def scan_ssh_vulnerabilities(port = 22)
    log("üîç Scan des vuln√©rabilit√©s SSH sur #{@target}:#{port}")
    
    vulns = []
    
    begin
      # Test de la version SSH
      socket = TCPSocket.new(@target, port)
      banner = socket.gets.chomp
      socket.close
      
      if banner.include?('SSH')
        vulns << {
          type: 'SSH Service',
          port: port,
          details: "SSH banner: #{banner}",
          severity: 'Info'
        }
        
        # V√©rifier les versions vuln√©rables
        if banner.include?('OpenSSH') && banner.include?('7.1')
          vulns << {
            type: 'SSH Version Vulnerability',
            port: port,
            details: "OpenSSH 7.1 may be vulnerable to CVE-2016-6210",
            severity: 'Medium'
          }
        end
      end
      
    rescue => e
      log("Erreur scan SSH: #{e.message}", 'WARNING')
    end
    
    @vulnerabilities.concat(vulns)
    return vulns
  end
  
  def scan_ftp_vulnerabilities(port = 21)
    log("üîç Scan des vuln√©rabilit√©s FTP sur #{@target}:#{port}")
    
    vulns = []
    
    begin
      socket = TCPSocket.new(@target, port)
      banner = socket.gets.chomp
      socket.close
      
      if banner.include?('FTP')
        vulns << {
          type: 'FTP Service',
          port: port,
          details: "FTP banner: #{banner}",
          severity: 'Info'
        }
        
        # Test FTP anonyme
        if test_anonymous_ftp(port)
          vulns << {
            type: 'Anonymous FTP Access',
            port: port,
            details: 'Anonymous FTP login allowed',
            severity: 'High'
          }
        end
      end
      
    rescue => e
      log("Erreur scan FTP: #{e.message}", 'WARNING')
    end
    
    @vulnerabilities.concat(vulns)
    return vulns
  end
  
  def test_anonymous_ftp(port)
    begin
      socket = TCPSocket.new(@target, port)
      banner = socket.gets.chomp
      
      # Envoyer USER anonymous
      socket.puts("USER anonymous")
      response = socket.gets.chomp
      
      if response.include?('331')
        socket.puts("PASS anonymous@example.com")
        response = socket.gets.chomp
        
        if response.include?('230')
          socket.close
          return true
        end
      end
      
      socket.close
      return false
      
    rescue => e
      return false
    end
  end
  
  def scan_database_vulnerabilities(port, service)
    log("üîç Scan des vuln√©rabilit√©s base de donn√©es sur #{@target}:#{port}")
    
    vulns = []
    
    case service
    when 'MySQL'
      vulns.concat(scan_mysql_vulnerabilities(port))
    when 'PostgreSQL'
      vulns.concat(scan_postgresql_vulnerabilities(port))
    end
    
    @vulnerabilities.concat(vulns)
    return vulns
  end
  
  def scan_mysql_vulnerabilities(port)
    vulns = []
    
    begin
      socket = TCPSocket.new(@target, port)
      banner = socket.gets.chomp
      socket.close
      
      if banner.include?('MySQL')
        vulns << {
          type: 'MySQL Service',
          port: port,
          details: "MySQL banner: #{banner}",
          severity: 'Info'
        }
        
        # Test de connexion sans mot de passe
        if test_mysql_connection(port)
          vulns << {
            type: 'MySQL No Password',
            port: port,
            details: 'MySQL accessible without password',
            severity: 'Critical'
          }
        end
      end
      
    rescue => e
      log("Erreur scan MySQL: #{e.message}", 'WARNING')
    end
    
    return vulns
  end
  
  def test_mysql_connection(port)
    # Test basique de connexion MySQL
    # Note: Ceci est un test simplifi√©
    return false
  end
  
  def scan_postgresql_vulnerabilities(port)
    vulns = []
    
    begin
      socket = TCPSocket.new(@target, port)
      banner = socket.gets.chomp
      socket.close
      
      if banner.include?('PostgreSQL')
        vulns << {
          type: 'PostgreSQL Service',
          port: port,
          details: "PostgreSQL banner: #{banner}",
          severity: 'Info'
        }
      end
      
    rescue => e
      log("Erreur scan PostgreSQL: #{e.message}", 'WARNING')
    end
    
    return vulns
  end
  
  def generate_vulnerability_report
    log("üìä G√©n√©ration du rapport de vuln√©rabilit√©s")
    
    report = {
      scan_time: Time.now.iso8601,
      target: @target,
      total_vulnerabilities: @vulnerabilities.length,
      vulnerabilities: @vulnerabilities,
      summary: {
        critical: @vulnerabilities.count { |v| v[:severity] == 'Critical' },
        high: @vulnerabilities.count { |v| v[:severity] == 'High' },
        medium: @vulnerabilities.count { |v| v[:severity] == 'Medium' },
        low: @vulnerabilities.count { |v| v[:severity] == 'Low' },
        info: @vulnerabilities.count { |v| v[:severity] == 'Info' }
      }
    }
    
    report_file = File.join(@output_dir, "vulnerability_report.json")
    File.write(report_file, JSON.pretty_generate(report))
    
    log("Rapport de vuln√©rabilit√©s g√©n√©r√©: #{report_file}")
    return report_file
  end
end

if __FILE__ == $0
  scanner = VulnerabilityScanner.new('192.168.1.1', 'results')
  
  # Test des vuln√©rabilit√©s web
  scanner.scan_web_vulnerabilities(80, false)
  scanner.scan_web_vulnerabilities(443, true)
  
  # Test des vuln√©rabilit√©s SSH et FTP
  scanner.scan_ssh_vulnerabilities(22)
  scanner.scan_ftp_vulnerabilities(21)
  
  # Test des vuln√©rabilit√©s base de donn√©es
  scanner.scan_database_vulnerabilities(3306, 'MySQL')
  scanner.scan_database_vulnerabilities(5432, 'PostgreSQL')
  
  # G√©n√©ration du rapport
  scanner.generate_vulnerability_report
end
